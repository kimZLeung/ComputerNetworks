## HTTP

---

## URI URL URN

- URL：URL属于URI，不但可以标识Web资源的位置，还指定了具体的操作和获取方式。同时指出了主要访问机制和网络位置
- URN：URN也属于URI，用特定命名空间的名字标识资源，使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。

for example

```
// URI 一个标识
http://test.io/posts/hello.html#intro

// URL 一个位置标识
http://test.io/posts/hello.html

// URN 一个名称标识
test.io/posts/hello.html#intro
```

- 初始版本的HTTP协议每进行一次HTTP通信就需要断开一次TCP连接，但是随着时代变迁，HTTP需要传输的东西多了起来，比如我们现在访问一个页面，需要发送的HTTP请求是几十级别的，因此要进行几十次级别的TCP三次握手和四次挥手，这将造成很多无谓的通信开销，所以HTTP/1.1和部分的HTTP/1.0实现了持久连接，就是HTTP一次传输完毕之后，只要没有说明确要断开，则会继续保持TCP连接。并且长连接让HTTP的管线化成为可能。管线化就是并行请求，不必等一个请求结束再开始另一个。

> 在HTTP/1.1中，所有连接都默认为持久连接，我们可以看到所有请求的请求头和响应头都带有`Connection`字段，默认为`keep-alive`，就是默认保持持久连接。当我们显式将其置为`close`的时候，将会关闭持久连接的方式。

- HTTP协议会通过编码把实体压缩，并在网络上传输，这样可以提高传输速率。提高传输速率的另一种方式就是，在面对比较大的实体时，HTTP会选择采用编码分割发送的方式，将实体分割成一个个块，又服务端接受并且解码，让服务端可以逐步展示页面。
- HTTP协议可以进行范围请求，服务端发的HTTP请求的头部带有一个字段`Range`来规定请求的范围。比如`Range: bytes=5001-`，服务端返回的响应的HTTP请求使用`Content-Range`来指定返回的范围，范围请求成功的状态码是206 Partial Content，若范围请求不成功。则会返回200 OK并且整个文件返回。
- HTTP协议还会进行内容协商返回。通过`Accept`，`Accept-Charset`，`Accept-Encoding`，`Accept-Language`，`Content-Language`这些包含在请求头部的字段，让服务端鉴别返回适合的内容（比如某网站的英文版或者中文版）。内容协商还分为三种类型
	- 服务器驱动，通过以上几个请求头鉴别返回内容
	- 客户端驱动协商，在页面上显示选项让用户选择
	- 透明协商，结合以上两种方法

---

## HTTP状态码

状态码通常会包含在响应报文的第一行，状态码是对返回的请求结果的一个简单描述。

粗略总结状态码类型：

- 1XX：信息性状态码，接受的请求正在处理
- 2XX：成功状态码，请求正常处理完毕
- 3XX：重定向状态码，需要进行附加操作以完成请求
- 4XX：客户端错误状态码，服务器无法处理请求
- 5XX：服务器错误状态码，服务器处理请求出错

具体到个别常用的状态码。

### 1XX 

- 100 Continue：客户端应继续发送请求。
- 101 Switching Protocols：需要切换协议，服务器通过的`Upgrade`响应头字段通知客户端。 HTML5引入的`WebSocket`便是这样工作的。首先客户端请求websocket所在的URL，服务器返回101，然后便建立了全双工的TCP连接。 注意`Upgrade`和`Connection`头字段属于`Hop-by-hop`字段，设置Websocket代理时需要继续设置这两个字段，而不是简单地转发请求。

### 2XX 成功

- 200 OK：最常见的状态码，表示请求被正常地成功处理了。但是在响应的报文中，会因为请求方法不同而不同，因为我们都知道用`GET`和`HEAD`方法获取的东西不同，`GET`会获取到实体主体。而`HEAD`方法只会让响应返回头部，并不会返回实体主体。
- 204 No Content：表示请求已被成功处理，但是返回的响应报文中不包含实体的主体部分。也就是没有内容。一般用在客户端向服务端发送信息，但是服务端不需要发送新信息的情况。
- 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

### 3XX 重定向

- 301 Moved Permanently：永久性重定向，表示请求的资源已被分配了新的URI，会自动重定向到新的URI，新的URI将会作为响应头的`Location`字段返回。并且如果用户此前将这个页面收藏为了书签，则301会帮助用户更新书签。
- 302 Found：临时性重定向，表示请求的资源已被分配了新的URI，希望本次能使用新的URI访问。与301不同的是，因为302表示的是临时性质，所以并不会去更新用户的书签。
- 303 See Other：该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。
- 304 Not Modified：服务端资源未改变，可直接使用客户端未过期的缓存。304和重定向没关系。
- 307 Temporary Redirect：临时重定向，和302有相同的含义。不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。

### 4XX 客户端错误

- 400 Bad Request：表示请求报文中存在语法错误，服务器无法理解这一次的请求。（有可能是参数错误之类的）当错误发生时，需修改请求的内容后再次发送请求。
- 401 Unauthorized：未授权，该状态码表示发送的请求需要通过认证。服务端会返回401并且在首部带有一个`WWW-Authenticate`的字段用以指明服务器需要哪种方式的认证。当客户端再次请求该资源的时候，需要在请求头中的`Authorization`包含认证信息。另外，若服务器第二次请求本URI仍然返回401，则表示用户认证失败。
- 403 Forbidden：该状态码表示了对请求资源的访问被服务器拒绝了。未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。
- 404 Not Found：表明服务器上无法找到请求的资源，也可以使用在拒绝请求的时候。

### 5XX 服务器错误

- 500 Internal Server Error：该状态码表明服务器端在执行请求时发生错误。也有可能是Web应用存在的bug。
- 503 Service Unavailable：该状态码表明服务器暂时处于高负载或者正在进行停机维护，暂时无法处理请求。可以通过返回的首部的`Retry-After`字段告诉客户端什么时候好。

> 因为部分功能性状态码需要由服务器维护人员显式根据需求设定，没有设定的话则又HTTP默认会变为200 OK或者404 Not Found或者500 Internal Server Error，这都是HTTP通过一些内置的判断生成的默认值。所以有时候，返回的状态码和响应时错误的，比如有时候服务器内部发生错误，但是状态码依旧返回200 OK。因为状态码有时候会通过HTTP默认设置，但是真实情况并不是这样子的，而在服务器那边并没有显示设定状态码导致了这种情况。

---

## HTTP协作的Web服务器

HTTP通信过程中除了客户端和服务端还可以存在

- 代理服务器
- 网关
- 隧道

> 代理服务器主要可以实现资源缓存（主要是响应返回时进行静态资源的缓存，缓存在代理的服务器中，但是会有缓存的时限，通过HTTP的一些头部协作），也可以实现一些类似访问限制之类的需求

> 网关能够使给服务器提供非HTTP协议服务，还可以提高通信的安全性，因为通过网关可以对通信线路进行加密

> 隧道可以确保客户端和服务端进行安全的（远距离的）通信

---

## HTTP的头部

具体可分为：

- 通用的头部字段：请求响应都可以使用的头部字段
- 请求用的头部字段：从客户端发送的请求会用到的头部字段，补充请求的附加内容，客户端信息之类的信息
- 响应的头部字段：从服务端返回的响应会用到的头部字段，补充响应的附加内容
- 实体头部字段：针对请求和响应报文的实体部分使用的头部，补充资源内容更新时间和实体有关的信息。

也可根据缓存代理和非缓存代理的行为分为2种类型

- 端到端头部：这一类头部会转发给最终接受目标，且会保存在由缓存生成的响应中
- 逐跳头部：这类头部只会对单次转发有效，会因为缓存或代理不再转发。具体头部如下
	- Connection
	- Keep-Alive
	- Proxy-Authenticate
	- Proxy-Authorization
	- Trailer
	- TE
	- Transfer-Encoding
	- Upgrade

---

## 认识HTTPS

> HTTP有很多不安全的地方，比如：传输过程中可能被认为窃听，通信的双方不能确认彼此真实身份，传输的报文的完整性不能得到保证。

所以 HTTPS = HTTP + 加密 + 认证 + 完整性保护

> 听起来好像牛逼了许多，但是HTTPS就是HTTP在通信接口部分用SSL和TLS协议代替了。HTTPS的通信变成了，HTTP先和SSL通信，然后SSL再和TCP通信，多一层SSL从而进行对HTTP通信的保护。


- 共享秘钥：把秘钥通过HTTP传输到对方，再让对方使用秘钥解密报文，但是把秘钥也发送出去这个过程也会有点点危险，可能会被盗取
- 公开密钥：使用一对秘钥。接收方把自己的公钥发给发送方，发送方用对方的公钥进行加密，发过去后由对方的私钥解密，但是这样做开销较大，速度较慢

HTTPS结合了这两种加密方式，进行混合加密：使用公开密钥的方式把共享的密钥通过安全的方式发给对方，然后通过共享秘钥进行消息的传输。

> 通常来说，服务端给客户端发送的第一次的公开密钥未必是**真正**的公开密钥，所以我们需要借助第三方的认证机构，为服务端生成公开密钥证书，然后服务端发送公开密钥证书过来客户端，客户端通过提前植入浏览器的私钥认证证书的有效性（认证），从而确认公开密钥的安全性，然后通过公开密钥加密共享秘钥，传送过去服务端，服务端通过自己的私钥解密，从而使双方都获取安全的共享秘钥（加密），然后就可以通过安全的共享秘钥进行信息传输。同时应用层会附加一种MAC的报文摘要，已确认报文的完整性（完整性保护）

HTTPS的缺点：由于要进行SSL通信，加密解密等操作，HTTPS与纯文本通信相比消耗更多的CPU和内存，简单来说就是开销会变大。因此，如果是非敏感信息则进行HTTP通信，只有在包含个人信息等敏感通信时才进行HTTPS通信

---




